module Method

imports
  Argument
  Block
  BodyStatement
  Command
  Expression
  Identifier
  JumpExpression
  Keyword
  MethodArgument
  Operator
  OperatorExpression
  Primary
  Separator
  Super
  Yield
  Variable
  Whitespace
  CompoundStatement

context-free syntax
  MethodId.LocalVar = <<LOCAL-V-IDENTIFIER>>
  MethodId.Constant = <<CONSTANT-IDENTIFIER>>
  MethodId.MethodOnly = <<METHOD-ONLY-IDENTIFIER>>

  MethodName.Id = <<MethodId>>
  MethodName.MethodOp = <<OPERATOR-METHOD-NAME>>
  MethodName.Keyword = <<KEYWORD>>
  
  MethodIdNoCons.LocalVar = <<LOCAL-V-IDENTIFIER>>
  MethodIdNoCons.MethodOnly = <<METHOD-ONLY-IDENTIFIER>>

  MethodNameNoCons.Id = <<MethodId>>
  MethodNameNoCons.MethodOp = <<OPERATOR-METHOD-NAME>>
  MethodNameNoCons.Keyword = <<KEYWORD>>
  
  // Method name without Constant Identifier
  MethodNameExceptConstant = MethodNameNoCons
  
  PrimaryMethodInvocation = SuperWithOptionalArgument
  PrimaryMethodInvocation = IndexingMethodInvocation
  PrimaryMethodInvocation = METHOD-ONLY-IDENTIFIER
  PrimaryMethodInvocation.Block = <<MethodId> <Block>>
  PrimaryMethodInvocation.ArgumentsBlock = 
    <<MethodId> <ArgumentWithParentheses> 
     <Block?>>
  PrimaryMethodInvocation.MethodInvocArg =
    <<Primary> . <MethodName> <ArgumentWithParentheses?>
      <Block?>>
  PrimaryMethodInvocation.MethodInvocColons = 
    <<Primary> :: <MethodName> <ArgumentWithParentheses>
      <Block?>>
  PrimaryMethodInvocation.MethodInvocNoCons = 
    <<Primary> :: <MethodNameExceptConstant> <ArgumentWithParentheses>
      <Block?>>
  
  IndexingMethodInvocation.IndexMethodInvoc = <<Primary> [ <IndexingArgumentList?> ]>

  MethodInvocationWithoutParentheses.Command = <<Command>>
  MethodInvocationWithoutParentheses.ChainedCommand = <<ChainedCommandWithDoBlock>>
  MethodInvocationWithoutParentheses.ChainedCommandLong = 
    <<ChainedCommandWithDoBlock> <BlockSymbol> <MethodName> <ArgumentWithoutParentheses>>
  MethodInvocationWithoutParentheses.Return = <<ReturnWithArgument>> {avoid}
  MethodInvocationWithoutParentheses.Break = <<BreakWithArgument>> {avoid}
  MethodInvocationWithoutParentheses.Next = <<NextWithArgument>> {avoid}
  
  Command.ComSuper = SuperWithArgument
  Command.ComYield = YieldWithArgument
  Command.ComMethod = MethodId ArgumentWithoutParentheses
  
syntax

  Command-CF.ComPrim = Primary-CF LAYOUT-NO-NEWLINE*-LEX BlockSymbol-CF LAYOUT?-CF MethodName-CF LAYOUT?-CF ArgumentWithoutParentheses-CF 

context-free syntax
  
  
  BlockSymbol.Period = "."
  BlockSymbol.DoubleColon = "::"
  
  ChainedCommandWithDoBlock.ChainedCommand =
    <<CommandWithDoBlock> <ChainedMethodInvocation*>>
  
  ChainedMethodInvocation.ChainedMethodInvoc = <<BlockSymbol> <MethodName>>
  ChainedMethodInvocation.ChainedMethodInvoc = 
    <<BlockSymbol> <MethodName> <ArgumentWithParentheses>>
    
  CommandWithDoBlock = SuperWithArgumentAndDoBlock
//  CommandWithDoBlock.CommandWithBlockNoPrim = 
//    <<MethodId> <ArgumentWithoutParentheses> <DoBlock>>   {avoid}
  CommandWithDoBlock.CommanWithBlock =
    <<Primary> <BlockSymbol> <MethodName> <ArgumentWithoutParentheses> <DoBlock>>
    
  
  
  // Primary Expression Method definition
  
syntax

  MethodDef-CF.MethodDef = "def" LAYOUT?-CF DefinedMethodName-CF LAYOUT-NO-NEWLINE*-LEX MethodParameters-CF LAYOUT?-CF BStmt-CF LAYOUT?-CF "end"
   
  SingletonMethodDef-CF.SingletonMethodDef = "def" LAYOUT?-CF Singleton-CF LAYOUT?-CF SingSep-CF LAYOUT?-CF DefinedMethodName-CF LAYOUT-NO-NEWLINE*-LEX MethodParameters-CF LAYOUT?-CF BStmt-CF LAYOUT?-CF "end"
  
  MethodParameters-CF.Params = ParamList?-CF LAYOUT-NO-NEWLINE*-LEX SEPARATOR-LEX SepListListExplicitEnd?-CF

context-free syntax

  DefinedMethodName.DefMethodName = MethodName
  DefinedMethodName.AssignMethodName = ASSIGNMENT-LIKE-METHOD-IDENTIFIER
  
  Singleton.Exp = <(<Exp>)>
  Singleton.VarRef = Var
  SingSep.Period = "."
  SingSep.Colons = "::"
  
  MethodParameters.ParamsWithParentheses = <( <ParamList?> )>
  
  ParamList.MandatoryParams =<<MandatoryParams> <OptionalOpt?> <OptionalArray?> <OptionalProc?>>
  ParamList.Optional = <<OptionalParams> <OptionalArray?> <OptionalProc?>>
  ParamList.Array = <<ArrayParams> <OptionalProc?>>
  ParamList.Proc = ProcParams
  
  MandatoryParams.Params = {MandatoryParam ","}+
  MandatoryParam.MandatoryParam = LOCAL-V-IDENTIFIER
  
  OptionalParams.Params = {OptionalParam ","}+
  OptionalParam.OptionalParam = <<OptionalParamName> = <OpExp>>
  OptionalParamName.Name = LOCAL-V-IDENTIFIER
  OptionalOpt.OptionalOptionalParams = <, <OptionalParams>>
  
  ArrayParams.ArrayParamsWithName = <* <ArrayParamName>>
  ArrayParams.ArrayParamStar = "*"
  ArrayParamName.Name = LOCAL-V-IDENTIFIER
  OptionalArray.OptionalArray = <, <ArrayParams>>
  
  ProcParams.ProcParam = <& <ProcParamName>>
  ProcParamName.ProcName = LOCAL-V-IDENTIFIER
  OptionalProc.OptionalProc = <, <ProcParams>>
  

