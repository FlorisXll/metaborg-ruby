module Primary

imports
  BodyStatement
  CompoundStatement
	Identifier
	Expression
	Literal
	Separator
	Statement
	Variable
	
// Primary stands for the primary expressions in Ruby 
context-free syntax

	Primary.Literal = <<Literal>>
	Primary.VarRef = <<Var>>
	Primary.Const = <<Primary> :: <ID>>
	
	// TODO: no line-terminator between class-name and superclass
	Primary.Class = 
	 < class <ClassPath> <SuperClass?> <Sep>
	   <BStmt>
	   end
	 >
	
	ClassPath.TopClassPath = <:: <ClassName>>
	ClassPath.ClassName = <<ClassName>>
	ClassName.ClassName = <<CONSTANT-IDENTIFIER>>
	// TODO: no line separater between Primary and "::"
	ClassPath.NestedClassPath = <<Primary> :: <ClassName>>
	
	SuperClass.Super = [ < [Exp]]
	
//	PRIMARY: "(" COMPSTMT ")"
//	| LITERAL
//	| VARIABLE
//	| PRIMARY :: IDENTIFIER
//	| :: IDENTIFIER
//	| PRIMARY "[" [ARGS] "]"
//	| "[" [ARGS [,]] "]"
//	| "{" [ARGS | ASSOCS [,]] "}"
//	| return ["(" [CALL_ARGS] ")"]
//	| yield ["(" [CALL_ARGS] ")"]
//	| defined? "(" ARG ")"
//	| FUNCTION
//	| FUNCTION "{" ["|" [BLOCK_VAR] "|"] COMPSTMT "}"
//	| if EXPR THEN
//	COMPSTMT
//	{elsif EXPR THEN
//	COMPSTMT}
//	[else
//	COMPSTMT]
//	end
//	| unless EXPR THEN
//	COMPSTMT
//	[else
//	COMPSTMT]
//	end
//	| while EXPR DO COMPSTMT end
//	| until EXPR DO COMPSTMT end
//	| case COMPSTMT
//	when WHEN_ARGS THEN COMPSTMT
//	{when WHEN_ARGS THEN COMPSTMT}
//	[else
//	COMPSTMT]
//	end
//	| for BLOCK_VAR in EXPR DO
//	COMPSTMT
//	end
//	| begin
//	COMPSTMT
//	{rescue [ARGS] DO
//	COMPSTMT}
//	[else
//	COMPSTMT]
//	[ensure
//	COMPSTMT]
//	end
//	| class IDENTIFIER [< IDENTIFIER]
//	COMPSTMT
//	end
//	| module IDENTIFIER
//	COMPSTMT
//	end
//	| def FNAME ARGDECL
//	COMPSTMT
//	end
//	| def SINGLETON (. | ::) FNAME ARGDECL
//	COMPSTMT
//	end